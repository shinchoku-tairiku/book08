@import: ../../shinchoku-tairiku.satyh/shinchoku-tairiku
@import: local

let-block +pocketberserker = '<
  +chapter?*?:(bib-items){Firebaseから始めるWebサービス開発}{終わりの始まり - ???}<
    +section{はじめに}<
      +p {
        技術的な発展に伴い、Webサービス開発を始めるための敷居は2010年代初頭に比べて圧倒的に下がっています。
      }
      +p {
        本章では、筆者がFirebaseとTypeScriptを用いてミニマルなサービス開発した際に感じたことを書き連ねます。
      }
    >
    +section{FirebaseとTypeScriptによるWebサービス開発}<
      +p {
        Firebase\cite(`fierbase`);はGoogleが提供するmBaaSです。
        モバイルのBackendに利用されるほか、Webサービスのバックエンドとして利用されることもあります。
      }
      +p {
        Firebaseの利点は手軽に素早く構築できるところです。
        ホスティング、認証、NoSQLデータベース、サーバーレス フレームワーク、ストレージが簡単に利用できるため、ある程度機能をもったサービスも効率よく開発できます。
      }
      +subsection{Firebase Hosting}<
        +p {
          FirebaseでWebページをホスティングする場合はFirebase Hostingを利用することがほとんどでしょう。
          Firebase HostingはCloud FunctionsやCloud Runと組み合わせることで、動的コンテンツを生成して配信できるからです。
        }
        +p {
          ホスティング機能のみが必要なときには、Firebase Hostingは他サービスに比べると見劣りする部分があるかもしれません。
          また、癖が強いように感じる部分もあるでしょう。
          そういったときはFirebaseにこだわらず別サービスを利用しましょう。
        }
      >
      +subsection{TypeScript}<
        +p {
          小さなWebサービスを素早く開発したい場合において、複数の言語を使うことそれ自体が足枷になりがちです。
          エコシステムが異なることによりビルドパイプラインが複雑化するからです。
          サービスが複雑化する前提であれば、FrontendとBackendで言語を分けることも最初から考えるのですが、とりあえず作ってみるという段階なら言語を絞ったほうが良いと筆者は考えています。
        }
        +p {
          筆者がミニマムなWebサービスを開発する際は、主にTypeScriptを使用しています。
        }
        +listing {
          * 静的型付け
          * ひとつの言語である程度Backendも書ける
          * Cloud Functions for Firebaseを利用するため
        }
        +p {
          筆者は静的型チェックがないと足を打ちぬきがちなので、まずJavaScriptが選択肢から外れます。
          そこから、エコシステムが煩雑でなく気楽に書ける言語（筆者の主観です）を考えた結果TypeScriptという安牌に落ち着きました。
        }
        +p {
          なお、これはあくまで開発序盤の話です。
          TypeScriptやNode.jsでは不足と感じたら別言語を検討します。
          例えば筆者の場合、RDBを導入すると決めたときは別言語に乗り換えるようにしています\footnote{昨今はprisma\cite(`prisma`);を使えばTypeScriptでも問題ないかもしれませんが、まだ未検証です}。
          コンテナ技術の発達により、導入や移行がより容易になっているので、数年前に比べればさほど苦ではないように思います。
        }
      >
      +subsection{Web FrontendのFramework}<
        +p {
          FrontendのFrameworkは様々なものがあり、どれを使うかは個人の趣味によると思われます。
          筆者は最近はもっぱらNext.jsを利用しています。
        }
        +listing {
          * 環境構築時に必要なものがまとめて入る
          * webpackを0から設定する必要がない
          * TypeScriptフレンドリー
        }
        +p {
          素のReactで1から環境構築しようとすると何かと大変ですが、最初からNext.jsを使えばルーティングやwebpackなどが一通り手に入るので大変重宝しています。
          あとはなんといっても、TypeScriptでしっかり型チェックを行える点です。
        }
        +p {
          余談ですが、プライベートな時間を使って本格的にWebアプリケーションを作り始めた2019年頃はNuxt.jsを使っていました。
          当時は日本の各種サービスでNuxt.js導入の話を見聞きしていたことが主な理由ですが、
          どうにもTypeScriptの恩恵が受けられない部分が多い感触があり、最近はあまり触れていません。
        }
      >
      +subsection{Firebase Authentication}<
        +p {
          Firebaseではユーザー認証のため機能やツールとしてFirebase Authenticationが用意されています。
        }
        +p {
          簡単に使えて便利なFirebase Authenticationですが、\code(`onAuthStateChanged`);による認証取得に待たされるためユーザー体験的には微妙、という問題があります。
          ネットワーク通信の関係上どうにもならないようので、適切にローディング処理を挿し込むか、Firebase Authenticationの利用を諦めましょう。
        }
        +p {
          筆者が実際に試してみた認証プロバイダーはGoogle, Twitter, そしてメールリンク方式です。
          Google Providerは本家なだけあって特にはまり所なく使えました。
          Twitter Providerは謎のエラーに苦しめられることがあるため（そして解決策を見つけられなかったため）あまりお勧めはできません。
        }
        +p {
          メールリンクも特に問題なく使えていますが、サインアップ時のメール文を変更できないといった難点があります。
          こういった制限を許容できないサービスを作ろうとしているなら、別サービスを利用するか自作する他ないでしょう。
        }
        +subsubsection{メールリンク方式の再認証}<
          +p {
            メールリンク方式で筆者が嵌った点として、メールアドレス変更処理があります。
            メールアドレス変更は再認証してからでないと行えないのですが、公式ドキュメントを読んだとおりに書いただけでは動かなかったのでした。
          }
          +p {
            次のコードは公式ドキュメントに記載されていたサンプルコード\cite(`re-authentication`);です。
            \d-code(```
              // Construct the email link credential from the current URL.
              var credential = firebase.auth.EmailAuthProvider.credentialWithLink(
                  email, window.location.href);
              
              // Link the credential to the current user.
              firebase.auth().currentUser.linkWithCredential(credential)
                .then(function(usercred) {
                  // The provider is now successfully linked.
                  // The phone user can now sign in with their phone number or email.
                })
                .catch(function(error) {
                  // Some error occurred.
                });
            ```);
            これを素直に取り入れるだけではエラーになって終わります。
            なぜかというと……再認証していないからです（！？）。
          }
          +p {
            正しくは、email変更ページでサインイン処理を実行し、
            メール文に記載されたリンクにアクセスしてリダイレクトされてから上記コードを呼び出す必要があります。
            \d-code(```
              // 変更前のemail
              firebase.auth().sendSignInLinkToEmail(currentEmail, {
                // サインイン処理後にemail変更ページのurlにリダイレクト
                window.location.href,
              });
            ```);
            このフローなら認証直後なのでエラーになることなくメール変更処理が行えます。
            \d-code(```
              await firebase.auth().currentUser?.updateEmail(newEmail);
              await firebase.auth().currentUser?.sendEmailVerification({
                // メール変更検証リンク
                url,
              });
            ```);
          }
        >
      >
      +subsection{Firestore}<
        +p {
          TODO: ちゃんと書く
        }
      >
      +subsection{Cloud Functions for Firebase}<
        +p {
          TODO: ちゃんと書く
        }
      >
      +subsection{Cloud Storage}<
        +p {
          TODO: ちゃんと書く
        }
      >
    >
    +section{FirebaseとGCP}<
      +subsection{Functions? GAE? Cloud Run?}<
        +p {
          筆者はだいたい次のように使い分けています。
        }
        +listing {
          * Firestoreのトリガー: Cloud Functions for Firebase
          * Cloud Storageのトリガー: Cloud Functions for Firebase
          * 簡単なスケジューラ: Cloud Functions for Firebase
          * 簡単なPubSub: Cloud Functions for Firebase
          * Web UI用のAPI: GAE
          * 重量級の依存ライブラリ: Cloud Run
          * 他言語で実装: Cloud Run
        }
        +p {
          基本的にな戦略としては、序盤はCloud Functionsで開発していき、問題が発生したら別の道具に切り替えます。
          例えば、PubSubの受信側で重たい処理をしたいときはCloud Runを使うことにしています。
        }
        +p {
          Cloud FunctionsやCloud Runはcold startが存在する関係上、どうしても素早くレスポンスを返すことができない場合があります。
          Node.jsではプロセス起動時にモジュール読み込みが発生するため、実装次第ではこの問題がより顕著になります。
          最適化するプラクティスが存在するとはいえ\footnote{Cloud Runで応答時間を最適化する方法は公式の記事\cite(`optimize-cloud-run-response-time`);があります}、0にできるものではありません。
          Webサービスを実装するうえで、cold startによる応答遅延はユーザー体験の悪化につながるので、気になるようなら他の道具（GAE, GKE）を検討しましょう\footnote{スモールスタートにするならGAE一択だと思います}。
        }
      >
      +subsection{Firestore? Cloud SQL?}<
        +p {
          TODO: 困ったらCloud SQL
        }
      >
    >
    +section{Firebaseでカバーできない部分}<
      +subsection{検索}<
        +p {
          TODO: AlgoliaやElasticsearchを使いましょう
        }
      >
      +subsection{メール送信}<
        +p {
          TODO: SendGridやmailgunを使いましょう
        }
      >
      +subsection{決済}<
        +p {
          TODO: 決済サービスを使いましょう
        }
      >
      +subsection{OGP画像の動的生成}<
        +p {
          TODO: Cloud FunctionsやCloud Runでどうにかできることも多いよ
          TODO: Cloudinary, Imgixなどを使うことも検討しましょう
        }
      >
    }
  >
>